<?php

namespace Modules\Hotel\Controllers;

use App\Http\Controllers\Controller;
use Carbon\Carbon;
use Modules\Hotel\Models\Hotel;
use Illuminate\Http\Request;
use Modules\Location\Models\Location;
use Modules\Location\Models\LocationCategory;
use Modules\Review\Models\Review;
use Modules\Core\Models\Attributes;
use DB;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Modules\Hotel\Models\HotelRoom;
use Modules\Hotel\Models\HotelRoomBooking;
use Modules\Hotel\Models\HotelRoomDate;
use Modules\Core\Models\Terms;

class HotelController extends Controller
{

    protected $hotelClass;
    protected $locationClass;
    protected $roomClass;
    protected $roomDateClass;
    protected $roomBookingClass;
    protected $termClass;
    protected $tmp_rooms = [];

    /**
     * @var string
     */
    private $locationCategoryClass;

    public function __construct(Hotel $hotel)
    {

        $this->roomClass = HotelRoom::class;
        $this->hotelClass = $hotel;
        $this->roomDateClass = HotelRoomDate::class;
        $this->locationClass = Location::class;
        $this->locationCategoryClass = LocationCategory::class;
        $this->roomBookingClass = HotelRoomBooking::class;
        $this->termClass = Terms::class;
    }

    public function callAction($method, $parameters)
    {

        if (!Hotel::isEnable()) {
            return redirect('/');
        }
        return parent::callAction($method, $parameters); // TODO: Change the autogenerated stub
    }

    public function index(Request $request)
    {
        $layout = setting_item("hotel_layout_search", 'normal');
        if ($request->query('_layout')) {
            $layout = $request->query('_layout');
        }
        $is_ajax = $request->query('_ajax');
        $for_map = $request->query('_map', $layout === 'map');

        if (!empty($request->query('limit'))) {
            $limit = $request->query('limit');
        } else {
            $limit = !empty(setting_item("hotel_page_limit_item")) ? setting_item("hotel_page_limit_item") : 9;
        }

        $query = $this->hotelClass->search($request->input());
        $list = $query->paginate($limit);

        $markers = [];
        if ($for_map and !empty($list)) {
            foreach ($list as $row) {
                $markers[] = [
                    "id"      => $row->id,
                    "title"   => $row->title,
                    "lat"     => (float)$row->map_lat,
                    "lng"     => (float)$row->map_lng,
                    "gallery" => $row->getGallery(true),
                    "infobox" => view('Hotel::frontend.layouts.search.loop-grid', ['row' => $row, 'disable_lazyload' => 1, 'wrap_class' => 'infobox-item'])->render(),
                    'marker' => get_file_url(setting_item("hotel_icon_marker_map"), 'full') ?? url('images/icons/png/pin.png'),
                ];
            }
        }
        $limit_location = 15;
        if (empty(setting_item("hotel_location_search_style")) or setting_item("hotel_location_search_style") == "normal") {
            $limit_location = 1000;
        }
        $data = [
            'rows' => $list,
            'layout' => $layout
        ];
        if ($is_ajax) {
            return $this->sendSuccess([
                "markers" => $markers,
                'fragments' => [
                    '.ajax-search-result' => view('Hotel::frontend.ajax.search-result' . ($for_map ? '-map' : ''), $data)->render(),
                    '.result-count' => $list->total() > 1 ? __(":count hotels found", ['count' => $list->total()]) : __(":count hotel found", ['count' => $list->total()]),
                    '.count-string' => $list->total() ? __("Showing :from - :to of :total Hotels", ["from" => $list->firstItem(), "to" => $list->lastItem(), "total" => $list->total()]) : ''
                ]
            ]);
        }

        $data = [
            'rows'               => $list,
            'list_location'      => $this->locationClass::where('status', 'publish')->limit($limit_location)->with(['translation'])->get()->toTree(),
            'hotel_min_max_price' => $this->hotelClass::getMinMaxPrice(),
            'markers'            => $markers,
            "blank" => setting_item('search_open_tab') == "current_tab" ? 0 : 1,
            "seo_meta"           => $this->hotelClass::getSeoMetaForPageList()
        ];
        $data['attributes'] = Attributes::where('service', 'hotel')->orderBy("position", "desc")->with(['terms' => function ($query) {
            $query->withCount('hotel');
        }, 'translation'])->get();
        $data['layout'] = $layout;

        if ($layout == "map") {
            $data['body_class'] = 'has-search-map';
            $data['html_class'] = 'full-page';
            return view('Hotel::frontend.search-map', $data);
        }
        return view('Hotel::frontend.search', $data);
    }

    public function detail(Request $request, $slug)
    {

        $hotel = $this->hotelClass::where('slug', $slug)->with(['location', 'translation', 'hasWishList', 'rooms'])->first();
        if (empty($hotel) or !$hotel->hasPermissionDetailView()) {
            return redirect('/');
        }
        $translation = $hotel->translate();
        $hotel_related = [];
        $location_id = $hotel->location_id;
        if (!empty($location_id)) {
            $hotel_related = $this->hotelClass::where('location_id', $location_id)->where("status", "publish")->take(4)->whereNotIn('id', [$hotel->id])->with(['location', 'translation', 'hasWishList'])->get();
        }
        $review_list = $hotel->getReviewList();

        $data = [
            'row'          => $hotel,
            'translation'       => $translation,
            'hotel_related' => $hotel_related,
            'location_category' => $this->locationCategoryClass::where("status", "publish")->with('location_category_translations')->get(),
            'booking_data' => $hotel->getBookingData(),
            'review_list'  => $review_list,
            'seo_meta'  => $hotel->getSeoMetaWithTranslation(app()->getLocale(), $translation),
            'body_class' => 'is_single',
            'breadcrumbs'       => [
                [
                    'name'  => __('Hotel'),
                    'url'  => route('hotel.search'),
                ],
            ],
        ];
        $data['breadcrumbs'] = array_merge($data['breadcrumbs'], $hotel->locationBreadcrumbs());
        $data['breadcrumbs'][] = [
            'name'  => $translation->title,
            'class' => 'active'
        ];

        $this->setActiveMenu($hotel);
        return view('Hotel::frontend.detail', $data);
    }


    public function checkAvailability()
    {
        $hotel_id = \request('hotel_id');


        if (\request()->input('firstLoad') == "false") {
            $rules = [
                'hotel_id'   => 'required',
                'start_date' => 'required:date_format:Y-m-d',
                'end_date'   => 'required:date_format:Y-m-d',
                'adults'     => 'required',
            ];
            $validator = \Validator::make(request()->all(), $rules);
            if ($validator->fails()) {
                return $this->sendError($validator->errors()->all());
            }

            if (strtotime(\request('end_date')) - strtotime(\request('start_date')) < DAY_IN_SECONDS) {
                return $this->sendError(__("Dates are not valid"));
            }
            if (strtotime(\request('end_date')) - strtotime(\request('start_date')) > 30 * DAY_IN_SECONDS) {
                return $this->sendError(__("Maximum day for booking is 30"));
            }
        }

        $hotel = $this->hotelClass::find($hotel_id);
        if (empty($hotel_id) or empty($hotel)) {
            return $this->sendError(__("Hotel not found"));
        }

        if (\request()->input('firstLoad') == "false") {
            $numberDays = abs(strtotime(\request('end_date')) - strtotime(\request('start_date'))) / 86400;
            if (!empty($hotel->min_day_stays) and  $numberDays < $hotel->min_day_stays) {
                return $this->sendError(__("You must to book a minimum of :number days", ['number' => $hotel->min_day_stays]));
            }

            if (!empty($hotel->min_day_before_booking)) {
                $minday_before = strtotime("today +" . $hotel->min_day_before_booking . " days");
                if (strtotime(\request('start_date')) < $minday_before) {
                    return $this->sendError(__("You must book the service for :number days in advance", ["number" => $hotel->min_day_before_booking]));
                }
            }
        }


        $rooms = $hotel->getRoomsAvailability(request()->input());


        return $this->sendSuccess([
            'rooms' => $rooms
        ]);
    }

    public function getBookedDates(Request $request)
    {

        $room_id = \request('room_id');

        $room = $this->roomClass::find($room_id);

        if (empty($room)) {
            return $this->sendError(__('room not found'));
        }


        $query = $this->roomDateClass::query();
        $query->where('target_id', $room_id)->where('active', '0');
        $rows =  $query->take(100)->get();

        if (!empty($rows)) {
            foreach ($rows as $row) {
                $row->start = date('y-m-d', strtotime($row->start_date));
                $row->end = date('y-m-d', strtotime($row->end_date));

                $current_date = new \DateTime($row->start_date); // Start date as DateTime object


                $row->hold_date = $current_date->format('y-m-d');
            }
        }

        $full_booked_rooms = $this->roomBookingClass::query()->where('bravo_hotel_room_bookings.room_id', $room_id)->active()
            ->get(['bravo_hotel_room_bookings.*']);

        if (!empty($full_booked_rooms)) {
            foreach ($full_booked_rooms as $booked_room) {
                $booked_room->start = date('Y-m-d', strtotime($booked_room->start_date));
                $booked_room->end = date('Y-m-d', strtotime($booked_room->end_date));

                // Generate the range of dates
                $current_date = new \DateTime($booked_room->start_date); // Start date as DateTime object

                $booked_room->full_booked_date = $current_date->format('y-m-d');
            }
        }

        return $this->sendSuccess([
            'rooms' => $rows,
            'full_booked_rooms' => $full_booked_rooms,
        ]);
    }



    public function getRoomDataAvailability(Request $request)
    {

        $room_id = \request('room_id');

        $rules = [
            'room_id'   => 'required',
            'start_date' => 'required:date_format:Y-m-d',
            'end_date'   => 'required:date_format:Y-m-d',
            'adults'     => 'required',
        ];
        $validator = \Validator::make(request()->all(), $rules);
        if ($validator->fails()) {
            return $this->sendError($validator->errors()->all());
        }

        if (strtotime(\request('end_date')) - strtotime(\request('start_date')) < DAY_IN_SECONDS) {
            return $this->sendError(__("Dates are not valid"));
        }
        if (strtotime(\request('end_date')) - strtotime(\request('start_date')) > 30 * DAY_IN_SECONDS) {
            return $this->sendError(__("Maximum day for booking is 30"));
        }


        $room = $this->roomClass::find($room_id);
        $hotel = $room->hotel;
        $res = null;
        $this->tmp_rooms = [];

        if (empty($room_id) or empty($room)) {
            return $this->sendError(__("Room not found"));
        }

        if ($room->isAvailableAt(request()->input())) {
            $translation = $room->translate();
            $terms = Terms::getTermsByIdForAPI($room->terms->pluck('term_id'));
            $term_features = [];
            $i = 0;
            if (!empty($terms)) {
                foreach ($terms as $term) {
                    if (!empty($term['child'])) {
                        foreach ($term['child'] as $child) {
                            $term_features[] = [
                                'icon' => $child['icon'] ?? 'fa fa-smile-o',
                                'title' => $child['title']
                            ];
                            $i++;
                            if ($i == 5) break;
                        }
                    }
                    if ($i == 5) break;
                }
            }

            $res = new \stdClass();
            $res->id = $room->id;
            // dd($request->all(), $room);
            $res->title = $translation->title;

            $res->price = $room->tmp_price ?? 0;
            $discountType = $hotel->discount_type;
            $discountAmount = $hotel->discount_amount;
            $TotalDiscountAmount = $discountType == "flat" ?  (float)$discountAmount : ((float)$room->tmp_price * (float)$discountAmount) / 100;
            // dd($TotalDiscountAmount);
            $res->discount_type = $discountType;
            $res->discount_amount = $discountAmount;
            $res->total_discount_amount = $TotalDiscountAmount;
            $res->discount_start_date = Carbon::parse($hotel->discount_start_date)->startOfDay() ?? null;
            $res->discount_end_date = Carbon::parse($hotel->discount_end_date)->startOfDay() ?? null;
            $res->offer_name = $room->offer_name ?? '';

            $formatted_price = '';
            $final_price = 0;
            if ($hotel->discount_amount) {
                $discount_start_date = Carbon::parse($hotel->discount_start_date)->startOfDay();
                $discount_end_date = Carbon::parse($hotel->discount_end_date)->startOfDay();
                $request_start_date = Carbon::parse($request->start_date)->startOfDay();
                $after_discount_price = (float)$room->tmp_price - (float)$TotalDiscountAmount;
                if ($request_start_date->between($discount_start_date, $discount_end_date)) {
                    $hotel->discount_amount > 0 ? $formatted_price = '<del>' . format_money($room->tmp_price) . '</del> ' . format_money($after_discount_price) : $formatted_price = format_money($room->tmp_price);
                    $hotel->discount_amount > 0 ? $final_price = (float)$after_discount_price : $final_price = (float)$room->tmp_price;
                } else {
                    $formatted_price = format_money($room->tmp_price);
                    $final_price = (float)$room->tmp_price;
                }
            } else {
                $formatted_price = format_money($room->tmp_price);
                $final_price = (float)$room->tmp_price;
            }
            // Modified code 30.06.24
            $res->final_price = $final_price;
            $unit_of_time = '<span class="unit">/' . ($room->tmp_nights > 1 ? __(':count nights', ['count' => $room->tmp_nights]) : __(':count night', ['count' => $room->tmp_nights])) . '</span>';
            //end Modify code 30.06.24
            $res->size_html = $room->size ? size_unit_format($room->size) : '';
            $res->beds_html = $room->beds ? 'x' . $room->beds : '';
            $res->adults_html = $room->adults ? 'x' . $room->adults : '';
            $res->children_html = $room->children ? 'x' . $room->children : '';
            $res->number_selected = 0;
            $res->number = (int)$room->tmp_number ?? 0;
            $res->min_day_stays = $room->min_day_stays ?? 0;
            $res->image = $room->image_id ? get_file_url($room->image_id, 'medium') : '';
            $res->tmp_number = $room->tmp_number;
            $res->gallery = $room->getGallery();
            $res->price_html = $formatted_price . ' ' . $unit_of_time;
            $res->price_text = $formatted_price . '/' . ($room->tmp_nights ? __(':count nights', ['count' => $room->tmp_nights]) : __(":count night", ['count' => $room->tmp_nights]));
            $res->terms = $terms;
            $res->term_features = $term_features;

            $this->tmp_rooms[] = $room;
        }

        if (empty($res)) {
            return $this->sendError(__("No room available with your selected date. Please change your search critical"));
        }

        return $res;
    }
}
